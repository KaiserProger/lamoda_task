// Code generated by MockGen. DO NOT EDIT.
// Source: internal/app/persistence/repositories/item.go
//
// Generated by this command:
//
//      mockgen -source internal/app/persistence/repositories/item.go -package services_test -typed
//

// Package services_test is a generated GoMock package.
package services_test

import (
        context "context"
		models "lamoda_task/internal/app/models"
        repositories "lamoda_task/internal/app/persistence/repositories"
        reflect "reflect"

        gomock "go.uber.org/mock/gomock"
)

// MockItemRepository is a mock of ItemRepository interface.
type MockItemRepository struct {
        ctrl     *gomock.Controller
        recorder *MockItemRepositoryMockRecorder
}

// MockItemRepositoryMockRecorder is the mock recorder for MockItemRepository.
type MockItemRepositoryMockRecorder struct {
        mock *MockItemRepository
}

// NewMockItemRepository creates a new mock instance.
func NewMockItemRepository(ctrl *gomock.Controller) *MockItemRepository {
        mock := &MockItemRepository{ctrl: ctrl}
        mock.recorder = &MockItemRepositoryMockRecorder{mock}
        return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockItemRepository) EXPECT() *MockItemRepositoryMockRecorder {
        return m.recorder
}

// GetStoredAt mocks base method.
func (m *MockItemRepository) GetStoredAt(ctx context.Context, itemCodes []int) ([]*repositories.StoredItem, error) {
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetStoredAt", ctx, itemCodes)
        ret0, _ := ret[0].([]*repositories.StoredItem)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}

// GetStoredAt indicates an expected call of GetStoredAt.
func (mr *MockItemRepositoryMockRecorder) GetStoredAt(ctx, itemCodes any) *MockItemRepositoryGetStoredAtCall {
        mr.mock.ctrl.T.Helper()
        call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStoredAt", reflect.TypeOf((*MockItemRepository)(nil).GetStoredAt), ctx, itemCodes)
        return &MockItemRepositoryGetStoredAtCall{Call: call}
}

// MockItemRepositoryGetStoredAtCall wrap *gomock.Call
type MockItemRepositoryGetStoredAtCall struct {
        *gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockItemRepositoryGetStoredAtCall) Return(arg0 []*repositories.StoredItem, arg1 error) *MockItemRepositoryGetStoredAtCall {
        c.Call = c.Call.Return(arg0, arg1)
        return c
}

// Do rewrite *gomock.Call.Do
func (c *MockItemRepositoryGetStoredAtCall) Do(f func(context.Context, []int) ([]*repositories.StoredItem, error)) *MockItemRepositoryGetStoredAtCall {
        c.Call = c.Call.Do(f)
        return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockItemRepositoryGetStoredAtCall) DoAndReturn(f func(context.Context, []int) ([]*repositories.StoredItem, error)) *MockItemRepositoryGetStoredAtCall {
        c.Call = c.Call.DoAndReturn(f)
        return c
}

// MockReserveRepository is a mock of ReserveRepository interface.
type MockReserveRepository struct {
	ctrl     *gomock.Controller
	recorder *MockReserveRepositoryMockRecorder
}

// MockReserveRepositoryMockRecorder is the mock recorder for MockReserveRepository.
type MockReserveRepositoryMockRecorder struct {
	mock *MockReserveRepository
}

// NewMockReserveRepository creates a new mock instance.
func NewMockReserveRepository(ctrl *gomock.Controller) *MockReserveRepository {
	mock := &MockReserveRepository{ctrl: ctrl}
	mock.recorder = &MockReserveRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockReserveRepository) EXPECT() *MockReserveRepositoryMockRecorder {
	return m.recorder
}

// FreeReservation mocks base method.
func (m *MockReserveRepository) FreeReservation(ctx context.Context, reservation []*models.ReservationItem) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FreeReservation", ctx, reservation)
	ret0, _ := ret[0].(error)
	return ret0
}

// FreeReservation indicates an expected call of FreeReservation.
func (mr *MockReserveRepositoryMockRecorder) FreeReservation(ctx, reservation any) *MockReserveRepositoryFreeReservationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FreeReservation", reflect.TypeOf((*MockReserveRepository)(nil).FreeReservation), ctx, reservation)
	return &MockReserveRepositoryFreeReservationCall{Call: call}
}

// MockReserveRepositoryFreeReservationCall wrap *gomock.Call
type MockReserveRepositoryFreeReservationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockReserveRepositoryFreeReservationCall) Return(arg0 error) *MockReserveRepositoryFreeReservationCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockReserveRepositoryFreeReservationCall) Do(f func(context.Context, []*models.ReservationItem) error) *MockReserveRepositoryFreeReservationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockReserveRepositoryFreeReservationCall) DoAndReturn(f func(context.Context, []*models.ReservationItem) error) *MockReserveRepositoryFreeReservationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetReservation mocks base method.
func (m *MockReserveRepository) GetReservation(ctx context.Context, itemsCount map[int]int) ([]*models.ReservationItem, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetReservation", ctx, itemsCount)
	ret0, _ := ret[0].([]*models.ReservationItem)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetReservation indicates an expected call of GetReservation.
func (mr *MockReserveRepositoryMockRecorder) GetReservation(ctx, itemsCount any) *MockReserveRepositoryGetReservationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetReservation", reflect.TypeOf((*MockReserveRepository)(nil).GetReservation), ctx, itemsCount)
	return &MockReserveRepositoryGetReservationCall{Call: call}
}

// MockReserveRepositoryGetReservationCall wrap *gomock.Call
type MockReserveRepositoryGetReservationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockReserveRepositoryGetReservationCall) Return(arg0 []*models.ReservationItem, arg1 error) *MockReserveRepositoryGetReservationCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockReserveRepositoryGetReservationCall) Do(f func(context.Context, map[int]int) ([]*models.ReservationItem, error)) *MockReserveRepositoryGetReservationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockReserveRepositoryGetReservationCall) DoAndReturn(f func(context.Context, map[int]int) ([]*models.ReservationItem, error)) *MockReserveRepositoryGetReservationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MakeReservation mocks base method.
func (m *MockReserveRepository) MakeReservation(ctx context.Context, orders []*models.ReservationItem) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MakeReservation", ctx, orders)
	ret0, _ := ret[0].(error)
	return ret0
}

// MakeReservation indicates an expected call of MakeReservation.
func (mr *MockReserveRepositoryMockRecorder) MakeReservation(ctx, orders any) *MockReserveRepositoryMakeReservationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MakeReservation", reflect.TypeOf((*MockReserveRepository)(nil).MakeReservation), ctx, orders)
	return &MockReserveRepositoryMakeReservationCall{Call: call}
}

// MockReserveRepositoryMakeReservationCall wrap *gomock.Call
type MockReserveRepositoryMakeReservationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockReserveRepositoryMakeReservationCall) Return(arg0 error) *MockReserveRepositoryMakeReservationCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockReserveRepositoryMakeReservationCall) Do(f func(context.Context, []*models.ReservationItem) error) *MockReserveRepositoryMakeReservationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockReserveRepositoryMakeReservationCall) DoAndReturn(f func(context.Context, []*models.ReservationItem) error) *MockReserveRepositoryMakeReservationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockWarehouseRepository is a mock of WarehouseRepository interface.
type MockWarehouseRepository struct {
	ctrl     *gomock.Controller
	recorder *MockWarehouseRepositoryMockRecorder
}

// MockWarehouseRepositoryMockRecorder is the mock recorder for MockWarehouseRepository.
type MockWarehouseRepositoryMockRecorder struct {
	mock *MockWarehouseRepository
}

// NewMockWarehouseRepository creates a new mock instance.
func NewMockWarehouseRepository(ctrl *gomock.Controller) *MockWarehouseRepository {
	mock := &MockWarehouseRepository{ctrl: ctrl}
	mock.recorder = &MockWarehouseRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWarehouseRepository) EXPECT() *MockWarehouseRepositoryMockRecorder {
	return m.recorder
}

// AddToStock mocks base method.
func (m *MockWarehouseRepository) AddToStock(ctx context.Context, reservation []*models.ReservationItem) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddToStock", ctx, reservation)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddToStock indicates an expected call of AddToStock.
func (mr *MockWarehouseRepositoryMockRecorder) AddToStock(ctx, reservation any) *MockWarehouseRepositoryAddToStockCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddToStock", reflect.TypeOf((*MockWarehouseRepository)(nil).AddToStock), ctx, reservation)
	return &MockWarehouseRepositoryAddToStockCall{Call: call}
}

// MockWarehouseRepositoryAddToStockCall wrap *gomock.Call
type MockWarehouseRepositoryAddToStockCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockWarehouseRepositoryAddToStockCall) Return(arg0 error) *MockWarehouseRepositoryAddToStockCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockWarehouseRepositoryAddToStockCall) Do(f func(context.Context, []*models.ReservationItem) error) *MockWarehouseRepositoryAddToStockCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockWarehouseRepositoryAddToStockCall) DoAndReturn(f func(context.Context, []*models.ReservationItem) error) *MockWarehouseRepositoryAddToStockCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Get mocks base method.
func (m *MockWarehouseRepository) Get(ctx context.Context, warehouseId int) (*models.Warehouse, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", ctx, warehouseId)
	ret0, _ := ret[0].(*models.Warehouse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockWarehouseRepositoryMockRecorder) Get(ctx, warehouseId any) *MockWarehouseRepositoryGetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockWarehouseRepository)(nil).Get), ctx, warehouseId)
	return &MockWarehouseRepositoryGetCall{Call: call}
}

// MockWarehouseRepositoryGetCall wrap *gomock.Call
type MockWarehouseRepositoryGetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockWarehouseRepositoryGetCall) Return(arg0 *models.Warehouse, arg1 error) *MockWarehouseRepositoryGetCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockWarehouseRepositoryGetCall) Do(f func(context.Context, int) (*models.Warehouse, error)) *MockWarehouseRepositoryGetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockWarehouseRepositoryGetCall) DoAndReturn(f func(context.Context, int) (*models.Warehouse, error)) *MockWarehouseRepositoryGetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RemoveFromStock mocks base method.
func (m *MockWarehouseRepository) RemoveFromStock(ctx context.Context, reservation []*models.ReservationItem) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveFromStock", ctx, reservation)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveFromStock indicates an expected call of RemoveFromStock.
func (mr *MockWarehouseRepositoryMockRecorder) RemoveFromStock(ctx, reservation any) *MockWarehouseRepositoryRemoveFromStockCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveFromStock", reflect.TypeOf((*MockWarehouseRepository)(nil).RemoveFromStock), ctx, reservation)
	return &MockWarehouseRepositoryRemoveFromStockCall{Call: call}
}

// MockWarehouseRepositoryRemoveFromStockCall wrap *gomock.Call
type MockWarehouseRepositoryRemoveFromStockCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockWarehouseRepositoryRemoveFromStockCall) Return(arg0 error) *MockWarehouseRepositoryRemoveFromStockCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockWarehouseRepositoryRemoveFromStockCall) Do(f func(context.Context, []*models.ReservationItem) error) *MockWarehouseRepositoryRemoveFromStockCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockWarehouseRepositoryRemoveFromStockCall) DoAndReturn(f func(context.Context, []*models.ReservationItem) error) *MockWarehouseRepositoryRemoveFromStockCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockTransactional is a mock of Transactional interface.
type MockTransactional struct {
	ctrl     *gomock.Controller
	recorder *MockTransactionalMockRecorder
}

// MockTransactionalMockRecorder is the mock recorder for MockTransactional.
type MockTransactionalMockRecorder struct {
	mock *MockTransactional
}

// NewMockTransactional creates a new mock instance.
func NewMockTransactional(ctrl *gomock.Controller) *MockTransactional {
	mock := &MockTransactional{ctrl: ctrl}
	mock.recorder = &MockTransactionalMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTransactional) EXPECT() *MockTransactionalMockRecorder {
	return m.recorder
}

// WithinTransaction mocks base method.
func (m *MockTransactional) WithinTransaction(arg0 context.Context, arg1 func(context.Context) error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithinTransaction", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// WithinTransaction indicates an expected call of WithinTransaction.
func (mr *MockTransactionalMockRecorder) WithinTransaction(arg0, arg1 any) *MockTransactionalWithinTransactionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithinTransaction", reflect.TypeOf((*MockTransactional)(nil).WithinTransaction), arg0, arg1)
	return &MockTransactionalWithinTransactionCall{Call: call}
}

// MockTransactionalWithinTransactionCall wrap *gomock.Call
type MockTransactionalWithinTransactionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionalWithinTransactionCall) Return(arg0 error) *MockTransactionalWithinTransactionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionalWithinTransactionCall) Do(f func(context.Context, func(context.Context) error) error) *MockTransactionalWithinTransactionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionalWithinTransactionCall) DoAndReturn(f func(context.Context, func(context.Context) error) error) *MockTransactionalWithinTransactionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
